<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC
    "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN"
    "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd">
<html xmlns:svg='http://www.w3.org/2000/svg' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
<head><meta http-equiv='Content-type' content='application/xhtml+xml;charset=utf-8' /><title></title></head>
<body>
<h1 id='high_performance_computing_lab6_report'>High Performance Computing Lab6 Report</h1>

<h2 id='peiwen_hu_hupvbuedu'>Peiwen Hu hupv@bu.edu</h2>

<h1 id='part_1__finding_omega'>Part 1 – Finding OMEGA</h1>

<h2 id='1what_are_the_overall_shapes'>1.What are the overall shapes?</h2>

<p>The overall shapes are like, a &#8220;U&#8221; shape where the optimal OMEGA falls into the nearly middle.</p>

<h2 id='2how_does_omega_change_with_array_size'>2.How does OMEGA change with array size?</h2>

<p>As the array size grows the optimal OMEGA moves slightly right meaning it becomes a little larger.</p>

<p>I tried different array sizes from as small as 10 to 70, which is larger than how much a cache can hold.</p>

<p>Size = 10:</p>

<p><img alt='a' src='figure/size10_O0.5_2_0.01.jpg' /></p>

<p><a href='csv/10_150_10_0.5_0.01.csv'>csv</a></p>

<p><img alt='a' src='figure/size20_O0.5_2_0.01.jpg' /></p>

<p><a href='csv/20_150_10_0.5_0.1.csv'>csv</a></p>

<p><img alt='a' src='figure/size30_O0.5_2_0.01.jpg' /></p>

<p><a href='csv/30_150_10_0.5_0.1.csv'>csv</a></p>

<p><img alt='a' src='figure/size40_O0.5_2_0.01.jpg' /></p>

<p><a href='40_150_10_0.5_0.1.csv'>csv</a></p>

<p><img alt='a' src='figure/size60_O0.5_2_0.01.jpg' /></p>

<p><a href='csv/60_150_10_0.5_0.1.csv'>csv</a></p>

<p><img alt='a' src='figure/size70_O0.5_1.5_0.01.jpg' /></p>

<p><a href='csv/70_100_5_0.5_0.01.csv'>csv</a></p>

<h2 id='3what_is_the_sensitivity_of_omega_selection_on_iterations_to_convergence'>3.What is the sensitivity of OMEGA selection on iterations to convergence?</h2>

<p>It&#8217;s quite sensitive. As I observed, every change of 0.1 of OMEGA results in approximately 500 iterations more or less.</p>

<h2 id='4given_a_near_optimal_omega_qualitatively_what_affects_the_number_of_iterations_to_convergence'>4.Given a (near) optimal OMEGA, qualitatively, what affects the number of iterations to convergence?</h2>

<p>I think the initialization may affect it. Now we are using randomized initialization and the statistical difference of the numbers affects the iterations.</p>

<h1 id='part_2__serial_sor_optimizations'>Part 2 – Serial SOR optimizations</h1>

<p>The plot are as follows:</p>

<p>base=8,iters=10,delta=8,block size=8:</p>

<p><img alt='a' src='figure/b8_i10_d8_block8.jpg' /></p>

<p>base=16,iters=10,delta=16,block size=16:</p>

<p><img alt='a' src='figure/b16_i10_d16_block16.jpg' /></p>

<p>base=32,iters=10,delta=32,block size=32:</p>

<p><img alt='a' src='figure/b32_i10_d32_block32.jpg' /></p>

<p>Yes it&#8217;s surprising. The reversed one used least iterations but most time per iteration, while the blocking one used most iterations but least time per iteration. And the total time of the normal one is the least, while that of the blocking one is the most.</p>

<p>It&#8217;s easy to understand that since blocking takes advantage of cache thus it reduces time on a single iteration.</p>

<h1 id='part_3_cost_of_multithreading'>Part 3 Cost of multithreading</h1>
</body></html>
